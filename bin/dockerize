#!/usr/bin/env bash
set -e
[[ "$debug" ]] && set -x

# shellcheck source=lib.sh
source "$(dirname "$(realpath "${BASH_SOURCE[0]}")")/lib.sh" || :

# this script assembles the parts needed for a magento cloud docker deployment and
# if supported tools/icons are detected, bundles into a OSX style app
# order of stpes matter because some operations depend on the results of others
#
# 1. the app from an existing env or git repo + branch
# 2. the database
# 3. the encryption key
# 4. any added media files (such as pub/media including styles.css from m2 sample data install)
#   - req before compose cache bundling for catalog media dedup if from existing
# 5. the composer cache
# 6. the docker-compose conf
#   - req after composer install
# 7. the launching script to install or use MDM
#

app_icon_path="$lib_dir/../icons/magento.icns"
status_menu_icon_path="$lib_dir/../icons/magento-logo.png"

create_platypus_app() {
  local name="$1" contents_dir="$2"
  platypus \
    --app-icon "$app_icon_path" \
    --status-item-kind 'Icon' \
    --status-item-icon "$status_menu_icon_path" \
    --interface-type 'Status Menu' \
    --interpreter '/usr/bin/env' \
    --interpreter-args '-P|/usr/local/bin:/bin|bash' \
    --overwrite \
    --text-background-color '#000000' \
    --text-foreground-color '#FFFFFF' \
    --name "$name" \
    --app-version 0.1 \
    -u 'Keith Bentrup' \
    --bundle-identifier 'com.magento.mdm' \
    "$lib_dir/launcher" \
    "$contents_dir.app"
  [[ -d $contents_dir ]] && {
    # mv app into app bundle
    mv "$contents_dir" "$contents_dir.app/Contents/Resources/app"
  }
  msg_w_newlines "Successfully created $contents_dir.app"
}

# currently used for testing
create_fake_platypus_app() {
  local name="$1" contents_dir="$2"
  mkdir -p "$contents_dir.app/Contents/Resources"
  cp "$lib_dir/launcher" "$contents_dir.app/Contents/Resources/script"
  [[ -d $contents_dir ]] && {
    # mv app into app bundle
    mv "$contents_dir" "$contents_dir.app/Contents/Resources/app"
  }
  msg_w_newlines "Successfully created $contents_dir.app"
}

create_bundled_app() {
  local name="$1" contents_dir="$2"
  # if old app exists, remove it
  [[ -d "$contents_dir.app" ]] && rm -rf "$contents_dir.app"
  if is_platypus_installed; then
    create_platypus_app "$name" "$contents_dir"
  elif is_mac; then
    error "Platypus is not installed."
  else 
    create_fake_platypus_app "$name" "$contents_dir"
  fi
}

print_usage() {
  echo "
Usage:
  $(basename "${BASH_SOURCE[0]}") can either clone an existing cloud environment OR 
  install a new Magento application from a Magento Cloud compatible git repository.

Options:
  -h                        Display this help
  -p project id             Project to clone
  -e environment id         Environment to clone
  -g git url                Git repository to install from
  -b branch                 Git branch for install (HEAD commit of branch will be used)
  -t tag                    Git tag for install (not compatible with '-b')
  -n name                   A descriptive, valid hostname for the specific Magento app (e.g. autoparts-b2b or fashion-b2c)
                            (invalid with detached app)
  -a /path/to/auth.json     Optional path to auth.json file if required by composer
  -i /path/to/file.icns     Optional path to icon for Platyplus OSX app bundle (Apple .icns file preferred)
  -m                        Include complete media cache (larger size and longer time to run but image resizing already done)
  -d                        Detached app - no incl. Magento app - can be used for testing, our demo PWA frontend, etc.
"
}

# parse options
while getopts "b:e:g:hdp:t:n:a:i:m" opt || [[ $# -eq 0 ]]; do
  case "$opt" in
    h ) print_usage; exit 0 ;;
    d ) detached=true ;;
    p ) pid="$OPTARG" ;;
    e ) env="$OPTARG" ;;
    g ) git_url="$OPTARG" ;;
    b ) branch="$OPTARG" ;;
    t ) tag="$OPTARG" ;;
    m ) media_cache=true ;;
    n ) app_hostname="$OPTARG" ;;
    a ) auth_json_path="$OPTARG" ;;
    i ) app_icon_path="$OPTARG" ;;
    \? )
      print_usage
      [[ -z "$OPTARG" ]] && error "Missing required option(s)."
      error "Invalid option: -$OPTARG" ;;
    : ) print_usage; error "Invalid option: -$OPTARG requires an argument" 1>&2 ;;
  esac
done

[[ $detached && $app_hostname ]] && 
  error "Name provided for magento app, but detached app also selected. Incompatible selection."

[[ $detached ]] && {
  create_bundled_app "$detached_project_name" "$HOME/Downloads/$detached_project_name"
  exit 0
}

[[ $app_hostname ]] && {
  is_valid_hostname "$app_hostname" ||
    error "Provided name must be a valid hostname accepted by web browsers."
}

# additional error checking
{
  { # pid and env are not empty but other related opts are
    [[ ! -z "$pid" ]] && [[ ! -z "$env" ]] && [[ -z "$git_url" ]] && [[ -z "$branch" ]] && [[ -z "$tag" ]] && \
      env_is_existing_cloud=true
  } ||
  { # git url and branch are not empty but other related opts are
    [[ ! -z "$git_url" ]] && [[ ! -z "$branch" ]] && [[ -z "$tag" ]] && [[ -z "$pid" ]] && [[ -z "$env" ]]
  } ||
  { # git url and tag are not empty but other related opts are
    [[ ! -z "$git_url" ]] && [[ ! -z "$tag" ]] && [[ -z "$branch" ]] && [[ -z "$pid" ]] && [[ -z "$env" ]]
  }
} ||
  error "
You must provide either:
  1) a project & environment id
- OR -
  2) a git url & a specific branch or tag
"
[[ -n "$auth_json_path" && ! -f "$auth_json_path" ]] && error "Composer auth file not found: $auth_json_path"
[[ ! -f "$app_icon_path" ]] && error "App icon not found: $app_icon_path"

# if an app_hostname is provided, use it. otherwise, determine one based on other input.
[[ $app_hostname ]] || {
  if is_existing_cloud_env; then
    magento-cloud -q || error "The magento-cloud CLI was not found. To install, run
    curl -svLS https://accounts.magento.cloud/cli/installer | php"
    app_hostname="$pid-$env"
  else
    is_valid_git_url "$git_url" || error "Please check your git url."
    git_repo=$(echo "$git_url" | perl -pe 's/.*\/(.*)\.git/\1/')
    app_hostname="$git_repo-$branch$tag"
  fi
  is_valid_hostname "$app_hostname" ||
    error "Could not create valid hostname from user inputs. Please specify one with the '-n' option."
}

# clone and then remove unwanted files from the git repo
tmp_app_dir="$HOME/Downloads/$app_hostname"
rm -rf "$tmp_app_dir" || :
if is_existing_cloud_env; then
  magento-cloud get -e "$env" --depth=0 "$pid" "$tmp_app_dir"
else
  git clone "$git_url" --branch "$branch$tag" --depth 1 "$tmp_app_dir" || {
    # if error, try branch/tag as commit
    git clone "$git_url" "$tmp_app_dir"
    cd "$tmp_app_dir"
    git checkout "$branch$tag"
    cd ..
  }
fi
rm -rf "$tmp_app_dir/.git"

# create a clean copy (before composer install) of repo to hold assets with the EE version appended to the dir name
# app_dir contents will be distributable unit
ee_version=$(
  perl -ne '
    undef $/;
    s/[\S\s]*(cloud-metapackage|magento\/product-enterprise-edition)"[\S\s]*?"version": "([^"]*)[\S\s]*/\2/m and print
  ' "$tmp_app_dir/composer.lock"
)
app_dir="$tmp_app_dir-$ee_version"
rm -rf "$app_dir" || :
cp -a "$tmp_app_dir" "$app_dir"

# if cloning existing env, download the media dir minus the cache
# this will cause significant redundancy of images until can be deduped
is_existing_cloud_env && {

  # extract current env DB into the expected dir
  mkdir -p "$app_dir/.docker/mysql/docker-entrypoint-initdb.d"
  magento-cloud db:dump -p "$pid" -e "$env" -d "$app_dir/.docker/mysql/docker-entrypoint-initdb.d"

  # extract only the encryption key from the env's app/etc/env.php
  mkdir -p "$app_dir/app/etc"
  magento-cloud ssh -p "$pid" -e "$env" "
    php -r '\$a = require_once(\"app/etc/env.php\");
    echo \"<?php return array ( \\\"crypt\\\"  => \";
    var_export(\$a[\"crypt\"]); echo \");\";'
  " > "$app_dir/app/etc/env.php"

  # get the env's media
  mkdir -p "$tmp_app_dir/pub/media"
  if [[ $media_cache ]]; then
    magento-cloud ssh -y -p "$pid" -e "$env" "/app/bin/magento catalog:images:resize"
  else
    media_cache_option="--exclude=cache"
  fi
  magento-cloud mount:download -y -p "$pid" -e "$env" -m pub/media --target "$tmp_app_dir/pub/media" $media_cache_option
  tar -C "$tmp_app_dir" -zcf "$app_dir/media.tar.gz" "pub/media"

}

# goals of the following composer operations:
# 1. create a compressed tar file of the composer cache needed to install the app so
#   a. smaller, more manageable distributable
#   b. fast install during build
#   c. no credentials needed in build container
# 2. use prestissimo to speed up the creation of the cache
# 3. do not run the composer.json install scripts (also to speed up the composer cache creation)
# 4. use modified version of magento-cloud-docker to create modified docker-compose files
# 5. restore original composer.json and composer.lock to ensure originals are used for deployment in containers
cd "$tmp_app_dir" || exit 1
[[ ! -z "$auth_json_path" ]] && # if auth.json provided, use it
  cp "$auth_json_path" "$tmp_app_dir"
[[ ! -f "auth.json" && ! $COMPOSER_AUTH ]] && 
  warning_w_newlines "No auth.json OR COMPOSER_AUTH env var file detected! 
Composer may be rate-limited and/or be unable to download required packages.
  " &&
  sleep 5
# backup for later restore
cp composer.json composer.json.bak
cp composer.lock composer.lock.bak
# install with original composer.lock (but with composer.json scripts skipped if they exist) 
# so exact versions needed for build in cache
python -c "import sys, json; data = json.load(sys.stdin); data.pop('scripts', 0); print(json.dumps(data))" \
  < composer.json.bak > composer.json
# run composer operations inside a version specific php container
script_for_tmp_php_container=$(mktemp)
cat << EOF > "$script_for_tmp_php_container"
#!/bin/bash
composer global require hirak/prestissimo --no-interaction # parallelize downloads (much faster)
composer install --no-suggest --no-ansi --no-interaction --no-progress --prefer-dist
# require (or replace if already required) the official magento cloud docker module with ours
# also note that a few envs may have a composer repo entry that needs to be updated
perl -i -pe 's/magento\/magento-cloud-docker.git/pmet-public\/magento-cloud-docker.git/' composer.json
grep -q 'pmet-public/magento-cloud-docker' composer.json ||
  composer config repositories.mcd git git@github.com:pmet-public/magento-cloud-docker.git
composer require magento/magento-cloud-docker:dev-develop --no-suggest --no-ansi --no-interaction --no-progress
./vendor/bin/ece-docker build:compose --host="$app_hostname"
EOF
chmod +x "$script_for_tmp_php_container"

# get php version of app
app_php_version=$(perl -ne '/type: (php:[^\s]*)/ and print $1' .magento.app.yaml)

# if using ssh, set ssh options
[[ $SSH_AUTH_SOCK ]] && {
  is_mac && SSH_AUTH_SOCK="/run/host-services/ssh-auth.sock"
  # home dir of container will /app
  ssh_auth_opts="--mount type=bind,src=$SSH_AUTH_SOCK,target=$SSH_AUTH_SOCK -e SSH_AUTH_SOCK=$SSH_AUTH_SOCK \
    --mount type=bind,src=$HOME/.ssh/known_hosts,target=/app/.ssh/known_hosts"
}

composer_image="pmetpublic/magento-cloud-docker-$app_php_version-cli-1.1"
docker pull "$composer_image"
cid="$(docker create $ssh_auth_opts -v "$PWD:/app:delegated" \
  -e COMPOSER_AUTH -e COMPOSER_HOME=.composer -e DEBUG=true \
  "$composer_image" /tmp/script_for_php_container)"
docker cp "$script_for_tmp_php_container" "$cid:/tmp/script_for_php_container"
docker start -a "$cid"
rm "$script_for_tmp_php_container"
cp -r docker-compose*.yml .docker "$app_dir"

# restore the original composer files for use in the build container later
mv composer.json.bak composer.json
mv composer.lock.bak composer.lock

# remove auth.json from distributable dir if it exists
rm "$app_dir/auth.json" 2> /dev/null || :

# use default cloud integration env database configuration, so ece-tools deploy will work the same for docker and cloud
grep -q DATABASE_CONFIGURATION "$app_dir/.magento.env.yaml" || perl -i -pe "s/^  deploy:\s*$/  deploy:
    DATABASE_CONFIGURATION:
      connection:
        default:
          username: user
          host: database.internal
          dbname: main
          password: ''
/" "$app_dir/.magento.env.yaml"


# special case: assuming some existing installed packages already have catalog imagery from modules in pub/media, we can delete that media
# this can significantly reduce composer archive size
is_existing_cloud_env && {
  find .composer -path "*/catalog/product/*.jpg" -delete || :
}
tar -zcf "$app_dir/.composer.tar.gz" .composer

# del tmp dir
cd "$app_dir" || exit 1

# current magento php image run as root, so root owns the files if not using docker desktop for mac
if is_mac; then
  rm -rf "$tmp_app_dir"
else
  sudo rm -rf "$tmp_app_dir"
fi

create_bundled_app "$app_hostname" "$app_dir"
